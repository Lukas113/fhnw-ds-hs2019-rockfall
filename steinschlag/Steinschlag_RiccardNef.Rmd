---
title: "R Notebook"
output: html_notebook
---
---
```{r}
library(tidyverse)
library(janitor)
library(lubridate)
library(grid)
library(gridExtra)
library(chron)
library(psych)
library(MASS)

# File bestimmen
setwd("C:/Studium/1.Semester_DS/Challenge_Steinschlag")

#Laden der CSV`s

out_1 = read.csv("out_1.csv")

out_2 = read.csv("out_2.csv")

sum(is.na(out_1))

# 5789 NA values in the table

sum(is.na(out_2))

# 951 NA values in the table

out_1_clean_columns <- remove_empty_cols(out_1)

out_2_clean_columns <- remove_empty_cols(out_2)

#Löschen der NA Werte mit "na.omit"

zone_1 <- na.omit(out_1_clean_columns)

zone_2 <- na.omit(out_2_clean_columns)

#überprüfen der NA Werte

sum(is.na(zone_1))

# 0 NA Werte

sum(is.na(zone_2))

#0 NA Werte

#Bedingung für bind(), Namen müssen gleich sein

```

# Ändern der Colnames
```{r}
colnames (zone_1)[colnames(zone_1)=="Datum"] <- "date"
colnames (zone_1)[colnames(zone_1)=="Uhrzeit"] <- "time"
colnames (zone_1)[colnames(zone_1)=="Masse..kg."] <- "mass"
colnames (zone_1)[colnames(zone_1)=="Geschwindigkeit..m.s."] <- "speed"

colnames (zone_2)[colnames(zone_2)=="Date"] <- "date"
colnames (zone_2)[colnames(zone_2)=="Uhrzeit"] <- "time"
colnames (zone_2)[colnames(zone_2)=="m..kg."] <- "mass"
colnames (zone_2)[colnames(zone_2)=="v..m.s."] <- "speed"


zone_1
zone_2
```

# Zone_1 + Zone_2 = zone_new ???
```{r}
# Zonen könnten zusammengefügt werden, doch inwiefern unterscheiden sich die Datensätze?

zone_1 %>%
  ggplot(aes(x=time, y= speed)) +
    geom_boxplot()

zone_2 %>%
  ggplot(aes(x=time, y= speed)) +
    geom_boxplot()

#Bemerkung: Daten sind viel zu sporadisch, dass man irgendeiene Kausaliätät feststellen lässt. Es ist auch schlech diese in einem Boxplot darzustellen. Ich will jetzt nur überprüfen wie sich die Merkmalsausprägungen der Datensätzte unterscheidne

zone_1 %>%
  ggplot(aes(x=speed)) +
    geom_bar()

zone_2 %>%
  ggplot(aes(x=speed)) +
    geom_bar()

#Barplot zeig ein deutlicher Unterschied in den Datensätzen zur Geschwindigkeit

stat_data_1 <- dplyr::select(describe(dplyr::select(zone_1, mass, speed)), mean, sd, median, min, max)

stat_data_2 <- dplyr::select(describe(dplyr::select(zone_2, mass, speed)), mean, sd, median, min, max)

stat_data_1
stat_data_2

#Zum vergleichen füge ich die Resistenten Datenpunkte zusammen, Name wird automatisch angepasst

stat_zone_new <- rbind(stat_data_1,stat_data_2)
stat_zone_new

# Man sieht das der Maximalwert der Masse und der Geschweindigkeit sich massiv unterscheidet
# Eindeutig sieht man, dass die maximale Geschwindigkeit des Datensatzes 1 deutschlich über dem Minimum der Geschwindigkeit des Datensatzes 1 ist. Bei der Masse ist range deutlich grösser. Dieses Angaben sind leicht aus den Werten des Medians und der range 


# Auswertung 1 : Mediane der Datensätze unterscheiden sich massiv, bei beiden Merkmalen(mass,speed)
# Auswertung 2 : Range der Datensätze unterscheidet sich massiv, bei beiden Merkmalen(mass,speed)
# Auswertung 3 : Standartnormalverteilung ist bei der Geschwindigkeit viel geringer als bei der Masse. Bei der Geschwindigkeit liegt der Median und das art. Mittel sehr nahe zusammen = symetrische Verteilung
# Auswertung 4 : Masse hat einen grossen Unterschied vom Median und at.Mittel, dass heisst es ist ein unsymetrische  Verteilung. Dies könnte mit einer Datentransformation entgegengewirkt werden. Die grossen Werte dürften nicht so fest ins Gewicht fallen, als sie es jetzt tun.


# Annahme 1 : Unterschiede der Datensätze kann zustandekommen, weil z.B die Messund des Datensatzes 2 an einer Stelle gemessen hat, wo die Absturzhöhe geringer ist und sich darum die Geschwindigkeit verringert.
# Annhame 2 : Die zwei Datensätze fungieren als Messung von 2 Winkeln. Sie können nicht zusammengefügt werden, das sich so die Korelation zwischen den Merkalen verändet. Doch kann man die Monte Carlo Simulation durch beide Datensätze ziehen.
```

# das Zeitformat
````{r}
# Erstellen der Zeitanalysedaten

# Zone 1
zone_1_Time <- zone_1 %>%
  mutate(dateTime = as.POSIXct(paste(date, time), format = "%Y-%m-%d %H:%M"))

zone_1_TimeDiff <- zone_1_Time %>%
  mutate(
    diff_secs = as.numeric(dateTime - lag(dateTime))+1,
    diff_mins =  as.numeric(diff_secs)/60,
    diff_hours =  as.numeric(diff_secs)/3600,
    diff_days =  as.numeric(diff_secs)/ 86400)

#Zone 2 
zone_2_Time <- zone_2 %>%
  mutate(dateTime = as.POSIXct(paste(date, time), format = "%Y-%m-%d %H:%M"))

zone_2_TimeDiff <- zone_2_Time %>%
  mutate(
    diff_hours = as.numeric (dateTime - lag(dateTime)) +1,
    diff_mins = diff_hours * 60,
    diff_secs = diff_hours * 3600,
     diff_days = diff_secs/ 86400)

zone_1_TimeDiff %>%
  ggplot() +
  geom_histogram(aes(x = diff_hours), binwidth = 10)

zone_1_TimeDiff %>%
  ggplot() +
  geom_bar(mapping = aes(x = diff_hours), fill = "steelblue")

zone_2_TimeDiff %>%
  ggplot() +
  geom_histogram(aes(x = diff_hours), binwidth = 10)

zone_2_TimeDiff %>%
  ggplot() +
  geom_bar(mapping = aes(x = diff_hours), fill = "steelblue")

head(zone_1_TimeDiff)
head(zone_2_TimeDiff)

#Der erste Wert muss gelöscht werden. Denn aus der Berechnung der Zeitdiffertenz ergibt sich die Annhame, dass die Messung bei dem ersten Steinschlag begonnen hat, und beim letzten Steinschlag aufgehört hat. 

sum(is.na(zone_1_TimeDiff))
#hat 1 NA Wert
sum(is.na(zone_2_TimeDiff))
#hat 1 NA Wert

zone_1_TimeDiff <- na.omit(zone_1_TimeDiff)
zone_2_TimeDiff <- na.omit(zone_2_TimeDiff)

sum(is.na(zone_1_TimeDiff))
#hat 0 NA Wert
sum(is.na(zone_2_TimeDiff))
#hat 0 NA Wert

#Ergebniss :
# - Eine Merkmalsausprägung musste gelöscht werde, das nun nur noch der Zeiz Unterschied untersuccht wird.

zone_1_TimeDiff
zone_2_TimeDiff
```

# Die Zeitanalyse
```{r}
# Es währe auf den ersten Blick sinnvoll eine Zeitreihe anzufertigen.

plot.ts(zone_1_TimeDiff)
plot.ts(zone_2)

# Die Zeitreihe zeigt alle Ereignisse aufeinaderfolgend.

# Auswertung 1 : Masse zeigt eine gewisse regelmässigkeit: alle c.a 30 Tage kommt ein grosser Stein herunter. Dies kann gleich wieder wiederlegt werden, indem man den zweiten Datensatz analysiert. Die Verteilung ist komlett anderst und auch die Skaliertung ist komplett andest. Denn Datensatz besitzt nur rund die Hälfte der Anzahl Erreignisse als Datensatz 1.

# Ergebiniss 1 : Einerseits verfälscht dieses Zusammenfügen "der Zeit in der nichts passierte" das Ergebniss, anderseits währen diese Werte eh alle bei 0. Das Ziel einer Zeitreihe ist eine gewisse Verteilung festzustellen, durch glätten und co. Dies ist nicht sinnvoll, da viele Werte bei auf 0 sind. Zeitreiehen manchen also nur Sinn wenn der Y-Wert nie auf 0 geht.

# Ergebniss 2 : Wie plotte ich eine Timeseries mit plot.ts mit order by dateTime

# Ergebniss 3 : lustiger Plot als zeitlicher Verlauf der Steinschlag Geschichte der 3 Monate, jedoch wenig ausschlusreich.

zone_1_TimeDiff %>%   
ggplot()+
  geom_bar(mapping = aes(x = diff_secs),fill = "steelblue")

# hier ist jede gemesene Stunde eine Klasse. Ansatz: Klasse statt Masse 
# Doch zuerst wird est mal die Diff_hour untersucht

stat_data_3 <- dplyr::select(describe(dplyr::select(zone_1_TimeDiff, diff_days,diff_hours, diff_mins, diff_secs)), mean, sd, median, min, max)

stat_data_3

stat_data_4 <- dplyr::select(describe(dplyr::select(zone_2_TimeDiff, diff_days,diff_hours, diff_mins, diff_secs)), mean, sd, median, min, max)

stat_data_4

stat_zone_new2 <- rbind(stat_data_3,stat_data_4)
stat_zone_new2

# Auswertung 2: Hier zeigt sich wieder ein grosser Unterschied der Datensätze. Vorallem die Standartnormalveteilung ist sehr unterschiedlich.

# Auswertung 3: Es ist keine Symetrische Verteilung, da der Median und das art.Mittel nicht nach beisammenliegen in Relation zur Range. 

# Ergebniss 5: Zeiteinheit muss überprüft werden, vielleicht gibt es eine Zeiteinheit, die eine symetrische Vertelung ausgibt. Zeiteinheiten wurden erweitert, Datensatz besitzt nun die Zeitdistanz zwischen den Erreichgnissen in Sekunden, Minuten, Stunden und Tagen.

# Ergebniss 6 : Klasse statt Masse. Ich könnte die Zeiteinheit immer weiter Aufteilen. Für die optimal Klassengrösse gibt es verschiedene Ansätze. Einer davon ist die Wurzel der Anzahl Erreignisse. Die Erreignisse sind in Datensatz 1= 67. In Datensatz 2 sind es 31. 
# Klassenaufteilung 1 = 8.18 -> 8
# Klassenaufteilung 2 = 5.56 -> 6

# Ergebniss 7 : Zeitabstand wurde in Klassen von Tagen unterteilt. Um die optimale Klassenbreite einzhalten wird die binwith auf 0.5 gesetzt. Nun gibt es 10 Klassen. Was meiner Ansicht einer guten Klasse statt Masse entspricht.

zone_1_TimeDiff %>%
  ggplot() +
  geom_histogram(aes(x = diff_hours), fill = "steelblue", binwidth = 6)

zone_2_TimeDiff %>%
  ggplot() +
  geom_histogram(aes(x = diff_mins), fill = "steelblue")
   
# Ergebniss 8 : Zeitabstand wurde in "zu einander regelmässgie" Klassen aufgeteilt. Nun mus nur noch die Wahrscheinlichkeit daraus berechnet werden. 

# Auswertung 4 = Die Auswertung der Untersuchung der ZEit zwischen den Ereignissen hat ergibt eine Wahrscheinlichkeitsberechnung. Der Druchschnitt der Abstände beträgt 30.55 Stunden mit Streung von 0 bis 133 Stunden. Aus dem Histogramm ist ersichtlich, dass es einen steilen Anstieg am Anfang gibt das sein Maxium bei c.a 10 Stunden erreicht und danach wieder abflacht. Das Maximum der Zeitabstände zwischen jeden Ereichnissen liegt bei 113 Stunden, jetzt ist die Frage ob dies auch das Maximum ist. Ich nehme an das das Maximum der Abstände bei einem Jahr liegt, denn dies ist die Zeit denn nach dieser Zeit kommt ja das neue Netz.
```

# Die Wahrscheinlichkeit des Zeitabstandes 1
```{r}
#Zone 1
stat_zone_new2


# Untersuchung welche Zeiteinheit am besten passt.
# Ich kann nur Datensatz 2 benutzen, weil er noch einen 0 Wert besitzt.

# GGplot für Tage

e_fit_mass_zone_2_d <- fitdistr(zone_2_TimeDiff$diff_days, "exponential")
lnrm_fit_mass_zone_2_d <- fitdistr(zone_2_TimeDiff$diff_days, "lognormal")
w_fit_mass_zone_2_d <- fitdistr(zone_2_TimeDiff$diff_days, "weibull")

ggplot(zone_2_TimeDiff, aes(sample = diff_days)) +
  stat_qq(distribution = qexp,
          dparams = list(e_fit_mass_zone_2_d$estimate[1]),
          geom = "line",
          aes(color = "exponential")) +
  stat_qq(distribution = qlnorm,
          dparams = list(lnrm_fit_mass_zone_2_d$estimate[1], lnrm_fit_mass_zone_2_d$estimate[2]),
          geom = "line",
          aes(color = "log normal")) +
  stat_qq(distribution = qweibull,
          dparams = list(w_fit_mass_zone_2_d$estimate[1], w_fit_mass_zone_2_d$estimate[2]),
          geom = "line",
          aes(color = "Weibull")) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
  scale_color_manual(name = "",
                     values = c("exponential" = "red",
                               # "gamma" = "blue",
                                "log normal" = "green",
                                "Weibull" = "orange"),
                     breaks = c("exponential",
                                #"gamma",
                                "log normal",
                                "Weibull")) +
  labs(title = "Q-Q Plot in Tagen")


#GGplot für Stunden

e_fit_mass_zone_2_h <- fitdistr(zone_2_TimeDiff$diff_hours, "exponential")
lnrm_fit_mass_zone_2_h <- fitdistr(zone_2_TimeDiff$diff_hours, "lognormal")
w_fit_mass_zone_2_h <- fitdistr(zone_2_TimeDiff$diff_hours, "weibull")

ggplot(zone_2_TimeDiff, aes(sample = diff_hours)) +
  stat_qq(distribution = qexp,
          dparams = list(e_fit_mass_zone_2_h$estimate[1]),
          geom = "line",
          aes(color = "exponential")) +
  stat_qq(distribution = qlnorm,
          dparams = list(lnrm_fit_mass_zone_2_h$estimate[1], lnrm_fit_mass_zone_2_h$estimate[2]),
          geom = "line",
          aes(color = "log normal")) +
  stat_qq(distribution = qweibull,
          dparams = list(w_fit_mass_zone_2_h$estimate[1], w_fit_mass_zone_2_h$estimate[2]),
          geom = "line",
          aes(color = "Weibull")) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
  scale_color_manual(name = "",
                     values = c("exponential" = "red",
                                "log normal" = "green",
                                "Weibull" = "orange"),
                     breaks = c("exponential",
                                "log normal",
                                "Weibull")) +
  labs(title = "Q-Q Plot in Stunden")


# QQ-plot für Minuten


e_fit_mass_zone_2_m <- fitdistr(zone_2_TimeDiff$diff_mins, "exponential")
lnrm_fit_mass_zone_2_m <- fitdistr(zone_2_TimeDiff$diff_mins, "lognormal")
w_fit_mass_zone_2_m <- fitdistr(zone_2_TimeDiff$diff_mins, "weibull")

ggplot(zone_2_TimeDiff, aes(sample = diff_mins)) +
  stat_qq(distribution = qexp,
          dparams = list(e_fit_mass_zone_2_m$estimate[1]),
          geom = "line",
          aes(color = "exponential")) +
  stat_qq(distribution = qlnorm,
          dparams = list(lnrm_fit_mass_zone_2_m$estimate[1], lnrm_fit_mass_zone_2_m$estimate[2]),
          geom = "line",
          aes(color = "log normal")) +
  stat_qq(distribution = qweibull,
          dparams = list(w_fit_mass_zone_2_m$estimate[1], w_fit_mass_zone_2_m$estimate[2]),
          geom = "line",
          aes(color = "Weibull")) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
  scale_color_manual(name = "",
                     values = c("exponential" = "red",
                                "log normal" = "green",
                                "Weibull" = "orange"),
                     breaks = c("exponential",
                                "log normal",
                                "Weibull")) +
  labs(title = "Q-Q Plot in Minuten")


# QQ-plot für Minuten


e_fit_mass_zone_2_s <- fitdistr(zone_2_TimeDiff$diff_secs, "exponential")
lnrm_fit_mass_zone_2_s <- fitdistr(zone_2_TimeDiff$diff_secs, "lognormal")
w_fit_mass_zone_2_s <- fitdistr(zone_2_TimeDiff$diff_secs, "weibull")

ggplot(zone_2_TimeDiff, aes(sample = diff_secs)) +
  stat_qq(distribution = qexp,
          dparams = list(e_fit_mass_zone_2_s$estimate[1]),
          geom = "line",
          aes(color = "exponential")) +
  stat_qq(distribution = qlnorm,
          dparams = list(lnrm_fit_mass_zone_2_s$estimate[1], lnrm_fit_mass_zone_2_s$estimate[2]),
          geom = "line",
          aes(color = "log normal")) +
  stat_qq(distribution = qweibull,
          dparams = list(w_fit_mass_zone_2_s$estimate[1], w_fit_mass_zone_2_s$estimate[2]),
          geom = "line",
          aes(color = "Weibull")) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
  scale_color_manual(name = "",
                     values = c("exponential" = "red",
                                "log normal" = "green",
                                "Weibull" = "orange"),
                     breaks = c("exponential",
                                "log normal",
                                "Weibull")) +
  labs(title = "Q-Q Plot in Sekunden")

# Auswertung 1 : Zur Fittung der Wahrscheinlichkeitsverteilung kommt es nicht auf die Zeitgrösse an und somit auch nicht auf die Binwith. 

# Auswertung 2 : Es lässt sich nur schwer sagen, welche Verteilung man nehmen sollte

# Ergebniss 1 : Der beste Fit ist die "log normal" verteilung, denn diese Verteilung ist am Anfange deutlich die beste und auch in dem Bereich wo alle Verteilungenn beginnen ungenau zu werden ist sie noch am besten. Nur bei den letzten Extrempunkten ist die log Verteilung am schlechtesten.

gDistTimeZ2 <- fitdistr(zone_2_TimeDiff$diff_mins, "log-normal")

gDistTimeZ2$estimate[1]
gDistTimeZ2$estimate[2]

```

# Die Wahrscheinlichket des Zeitabstandes 2 
```{r}
# 1 Wert ist 0 weil der Zeitabstand weniger als eine Stunde war

# QQ-plot für Sekunden

zone_1_TimeDiff

e_fit_mass_zone_1_s <- fitdistr(zone_1_TimeDiff$diff_secs, "exponential")
w_fit_mass_zone_1_s <- fitdistr(zone_1_TimeDiff$diff_secs, "weibull")

ggplot(zone_1_TimeDiff, aes(sample = diff_secs)) +
  stat_qq(distribution = qexp,
          dparams = list(e_fit_mass_zone_1_s$estimate[1]),
          geom = "line",
          aes(color = "exponential")) +
  stat_qq(distribution = qweibull,
          dparams = list(w_fit_mass_zone_1_s$estimate[1], w_fit_mass_zone_1_s$estimate[2]),
          geom = "line",
          aes(color = "Weibull")) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
  scale_color_manual(name = "",
                     values = c("exponential" = "red",
                                "Weibull" = "orange"),
                     breaks = c("exponential",
                                "Weibull")) +
  labs(title = "Q-Q Plot in Sekunden")

show(zone_1_TimeDiff)
  
# Ergebniss 1 : Die Verteilung die am besten passt ist die exponentialverteilung.

gDistTimeZ1 <- fitdistr(zone_2_TimeDiff$diff_mins, "exponential")
gDistTimeZ1$estimate[1]
```

# Ergebnisss der Wahrscheinlichkeit für den Zeitabstand
```{r}
parameter_zone_1 <- gDistTimeZ1$estimate[1]

save(gDistTimeZ1,file = "DeltaT1Exponanitial.RData")
save(gDistTimeZ2,file = "DeltaT2LogNormal.RData")



parameter_zone_1
parameter_zone_2_a
parameter_zone_2_b
```

# Die anderen Wahrscheinlichkeiten
````{r}
# ein Stein hat die Masse 0, dies könnte noch Probleme verursachen. Ein Stein mit der Masse 0 ist kein Stein, oder ein Null Stein. Also wird er aus dem Datensatz gelöscht

zone_1 <- subset(zone_1, mass != 0)

zone_2 <- subset(zone_2, mass != 0)

#Zusätzliche Row in zone erstellen, mit mutate()
zone_1_energy <- zone_1 %>%
  mutate(energy =  (((mass * speed^2 )/2)/1000))

zone_2_energy <- zone_2 %>%
  mutate(energy =  (((mass * speed^2 )/2)/1000))

ggplot(data = zone_1_energy) +
  geom_histogram(mapping = aes(x=energy), fill = "steelblue")

ggplot(data = zone_2_energy) +
  geom_histogram(mapping = aes(x=energy), fill = "red")

ggplot(data = zone_1_energy) +
  geom_histogram(mapping = aes(x=mass), fill = "steelblue")

ggplot(data = zone_2_energy) +
  geom_histogram(mapping = aes(x=mass), fill = "red")

ggplot(data = zone_1_energy) +
  geom_histogram(mapping = aes(x=speed), fill = "steelblue")

ggplot(data = zone_2_energy) +
  geom_histogram(mapping = aes(x=speed), fill = "red")
````

# Die Tageszeituntersuchung
````{r}
ggplot(data = zone_1)+
  geom_bar(mapping = aes(x = time),fill = "steelblue")+ 
  coord_flip()

ggplot(data = zone_2)+
  geom_bar(mapping = aes(x = time),fill = "red")+ 
  coord_flip()

zone_1_TimeDiff %>%
    ggplot(aes(x=time, y= diff_hours)) +
    geom_boxplot()

zone_2_TimeDiff %>%
    ggplot(aes(x=time, y= diff_hours)) +
    geom_boxplot()

# Auswertung 1 = Die Verteilung der in der Tageszeit ist sehr unregelmässig. Man sieht im Bar-chart, dass die Verteilung sehr schwankt, was im Boxplot noch genauer ersichlich ist.

# Ergbebiss 1 = Die Wahrscheinlichkeit der vohergesagten Tageszeit wird vorerst vernachläigt, weil die Daten zu sehr gestreut sind.
````

# Zusatz
````{r}
#zeigt die Wahrscheinlichkeit ob ein Steinschlag passiert pro Stunde

wahrscheinlichkeit <-zone_new %>%
                    count(time) %>%
                    mutate(probability = n/90)



#zeigt die Wahrscheinlichkeit ob ein Steinschlag passiert

wahrscheinlichkeitGesammt <- zone_new %>%
                          count(time) %>%
                          mutate(probability = n/2160)

  
````

